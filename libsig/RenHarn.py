from gmpy2 import invert, gcd
from hashlib import sha256

from libsig.primes import gen_prime, is_safe_prime
from libsig.secrets import randrange
from libsig.AbstractSignatureScheme import AbstractSignatureScheme
from libsig.AbstractRingSignatureScheme import AbstractRingSignatureScheme


class RenHarn(AbstractRingSignatureScheme):
    """
    Implements the "Ring Signature Based on ElGamal Signature" by Jian Ren and Lein Harn

    >>> (e, d) = RenHarn.keygen(512)
    >>> privkeys = [d]
    >>> pubkeys = [e]
    >>> for _ in range(15):
    >>>     (e, d) = RenHarn.keygen(512, pubkeys[0][1], pubkeys[0][2])
    >>>     privkeys.append(d)
    >>>     pubkeys.append(e)
    >>> message = str.encode("Star wars is awesome")
    >>> sig = RenHarn.ringsign(privkeys[0], pubkeys, message)
    >>> RenHarn.verify(pubkeys, message, sig)
    True
    """
    @staticmethod
    def keygen(size=1024, g=None, p=None):
        """
        Generate a new (public, private)-key-pair.
        If a generator and a prime are supplied, they are used for the key-generation

        :param size: The security parameter, larger is better. Recommended is at least 512
        :type size: integer or None
        :param g: The generator of the group Z/pZ, common for all keys in a ring
        :type g: integer or None
        :param p: The prime of the group Z/pZ, common for all keys in a ring
        :type p: integer or None
        :return: A tuple consisting of the pubkey = (key, g, p) and the privkey = (key, g, p)
        """
        if (p is None) or (g is None):
            return ElGamal.keygen(size)
        else:
            d = randrange(2, p - 1)
            e = pow(g, d, p)
            return (e, g, p), (d, g, p)

    @staticmethod
    def ringsign(privkey, pubkeys, message):
        """
        Creates a ringsignature for the supplied message

        :param privkey: The private key tuple of the signer
        :type privkey: (key: integer, g: integer, p: integer)
        :param pubkeys: An array with the public key tuples of all members of the ring
        :type pubkeys: [(key: integer, g: integer, p: integer)]
        :param message: The message to be signed
        :type message: valid utf-8 bytes
        :return: The signature for the message
        """
        assert all(map(lambda x: x[1] == privkey[1] and x[2] == privkey[2], pubkeys))
        (d, g, p) = privkey
        h = lambda m: int(sha256(m).hexdigest(), 16)
        k = h(message)
        message = str(message)
        v = randrange(1, p)
        messages = []
        n = len(pubkeys)
        for i in range(n):
            e_i = pubkeys[i][0]
            a_i = randrange(1, p - 1)
            while 1:
                b_i = randrange(1, p - 1)
                if gcd(b_i, p - 1) == 1:
                    break
            alpha_i = (pow(g, a_i, p) * pow(e_i, b_i, p)) % p
            beta_i = (- alpha_i * invert(b_i, p - 1)) % (p - 1)
            m_i = (a_i * beta_i) % (p - 1)
            messages.append((m_i, alpha_i, beta_i))
        messages[0] = (0, None, None)
        v_i_s = [None]*n
        v_i_s[1] = h(str.encode(message + str(v)))
        for i in [(x % n) for x in range(2, n+1)]:
            tmp = (v_i_s[i - 1] + messages[i - 1][0]) % p
            v_i_s[i] = h(str.encode(message + str(tmp)))
        messages[0] = (v - v_i_s[0], None, None)
        while 1:
            l = randrange(2, p)
            if gcd(l, p - 1) == 1:
                break
        alpha_s = pow(g, l, p)
        beta_s = ((messages[0][0] - d * alpha_s) * invert(l, p - 1)) % (p - 1)
        messages[0] = (messages[0][0], alpha_s, beta_s)
        for i in range(n):
            assert pow(g, messages[i][0], p) == (pow(pubkeys[i][0], messages[i][1], p) * pow(messages[i][1], messages[i][2], p)) % p
        z = randrange(0, n)
        return z, v_i_s[z], messages

    @staticmethod
    def verify(pubkeys, message, sig):
        """
        Verifies a signature

        :param pubkeys: An array with the public key tuples of all members of the ring
        :type pubkeys: [(key: integer, g: integer, p: integer)]
        :param message: The message that was signed
        :type message: valid utf-8 bytes
        :param sig: The signature generated by :func:`ringsign`
        :return: True iff sig is a valid signature for the message
        """
        if any(map(lambda x: x[1] != pubkeys[0][1] or x[2] != pubkeys[0][2], pubkeys)):
            return False
        (_, g, p) = pubkeys[0]
        (i_0, v_i_0, ms) = sig
        message = str(message)
        assert len(pubkeys) == len(ms)
        n = len(pubkeys)
        for i in range(n):
            if pow(g, ms[i][0], p) != (pow(pubkeys[i][0], ms[i][1], p) * pow(ms[i][1], ms[i][2], p)) % p:
                return False
        h = lambda m: int(sha256(m).hexdigest(), 16)
        v = h(str.encode(message + str((ms[i_0][0] + v_i_0) % p)))
        for i in range(1, n):
            v = h(str.encode(message + str((ms[(i + i_0) % n][0] + v) % p)))
        return v == v_i_0


class ElGamal(AbstractSignatureScheme):
    @staticmethod
    def keygen(size=1024):
        """
        Generate a new (public, private)-key-pair.

        :param size: The security parameter, larger is better. Recommended is at least 512
        :type size: integer or None
        :return: A tuple consisting of the pubkey = (key, g, p) and the privkey = (key, g, p)
        """
        p = gen_prime(size, extra_check=is_safe_prime)
        q = p // 2
        while 1:
            g = randrange(3, p)
            if pow(g, 2, p) == 1:
                continue
            if pow(g, q, p) == 1:
                continue
            if divmod(p - 1, g)[1] == 0:
                continue
            if divmod(p - 1, invert(g, p))[1] == 0:
                continue
            break
        d = randrange(2, p - 1)
        e = pow(g, d, p)
        return (e, g, p), (d, g, p)

    @staticmethod
    def sign(privkey, message):
        """
        Creates a signature for the supplied message

        :param privkey: The private key tuple of the signer
        :type privkey: (key: integer, g: integer, p: integer)
        :param message: The message to be signed
        :type message: valid utf-8 bytes
        :return: The signature for the message
        """
        (d, g, p) = privkey
        m = int(sha256(message).hexdigest(), 16)
        l = randrange(2, p - 1)
        while gcd(l, p - 1) != 1:
            l = randrange(2, p - 1)
        alpha = pow(g, l, p)
        beta = ((m - d * alpha) * invert(l, p - 1)) % (p - 1)
        return alpha, beta

    @staticmethod
    def verify(pubkey, message, signature):
        """
        Verifies a signature

        :param pubkey: The public key tuple of the signer
        :type pubkey: (key: integer, g: integer, p: integer)
        :param message: The message that was signed
        :type message: valid utf-8 bytes
        :param signature: The signature generated by :func:`sign`
        :return: True iff signature is a valid signature for the message
        """
        (e, g, p) = pubkey
        alpha, beta = signature
        if alpha < 1 or alpha >= p:
            return False
        m = int(sha256(message).hexdigest(), 16)
        return pow(g, m, p) == (pow(e, alpha, p) * pow(alpha, beta, p)) % p
