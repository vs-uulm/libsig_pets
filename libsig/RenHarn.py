from libsig.primes import gen_prime, is_safe_prime
from libsig.secrets import randrange
from gmpy2 import invert, gcd
from hashlib import sha256


class RenHarn:
    @staticmethod
    def keygen(size=1024, p=None, g=None):
        """returns a (public, private, generator, prime)-keypair."""
        if (p is None) or (g is None):
            return ElGamal.keygen(size)
        else:
            d = randrange(2, p - 1)
            e = pow(g, d, p)
            return {'e': e, 'd': d, 'g': g, 'p': p}

    @staticmethod
    def ringsign(privkey, pubkeys, message, p, g, s):
        """returns a signature. The privkey is the private key
        generated by keygen. pubkeys is an array of the public keys in
        the ring, including the pubkeys corresponding to privkey. The
        message is an array of bytes.
        """
        k = int(sha256(message).hexdigest(), 16)
        v = randrange(1, p)
        messages = []
        n = len(pubkeys)
        indices = [i for i in range(n) if i != s] # s = index of signer
        for i in indices:
            e_i = pubkeys[i]
            a_i = randrange(1,p-1)
            while(1):
                b_i = randrange(1, p-1)
                if gcd(b_i, p-1) == 1:
                    break
            α_i = pow(g, a_i, p)*pow(e_i, b_i, p) % p
            β_i = - α_i * invert(b_i, p-1) % (p-1)
            m_i = a_i * β_i % (p-1)
            messages.append(m_i)

        raise NotImplementedError

    @staticmethod
    def verify(pubkeys, message, signature):
        """returns True if the signature is correct."""
        raise NotImplementedError


class ElGamal:
    @staticmethod
    def keygen(size=1024):
        """returns a (public, private, generator, prime)-keypair."""
        p = gen_prime(size, extra_check=is_safe_prime)
        q = p//2
        while 1:
            g = randrange(3, p)
            if pow(g, 2, p) == 1:
                continue
            if pow(g, q, p) == 1:
                continue
            if divmod(p-1, g)[1] == 0:
                continue
            if divmod(p - 1, invert(g, p))[1] == 0:
                continue
            break
        d = randrange(2, p - 1)
        e = pow(g, d, p)
        return {'e': e, 'd': d, 'g': g, 'p': p}

    @staticmethod
    def sign(d, message, g, p):
        """returns a signature. The privkey is the private key
        generated by keygen. The message is an array of bytes.
        """
        m = int(sha256(message).hexdigest(), 16)
        l = randrange(2, p - 1)
        while gcd(l, p - 1) != 1:
            l = randrange(2, p - 1)
        α = pow(g, l, p)
        β = (m - d*α)*invert(l, p - 1) % (p - 1)
        return α, β

    @staticmethod
    def verify(e, message, signature, g, p):
        """returns True if the signature is correct."""
        α, β = signature
        if α < 1 or α >= p:
            return False
        m = int(sha256(message).hexdigest(), 16)
        return pow(g, m) == pow(e, α, p)*pow(e, α, p) % p
