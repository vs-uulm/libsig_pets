from gmpy2 import invert, gcd
from hashlib import sha256

from libsig.primes import gen_prime, is_safe_prime
from libsig.secrets import randrange


class RenHarn:
    @staticmethod
    def keygen(size=1024, p=None, g=None):
        """returns a (public, private, generator, prime)-keypair."""
        if (p is None) or (g is None):
            return ElGamal.keygen(size)
        else:
            d = randrange(2, p - 1)
            e = pow(g, d, p)
            return {'e': e, 'd': d, 'g': g, 'p': p}

    @staticmethod
    def ringsign(privkey, pubkeys, message, p, g, s):
        """returns a signature. The privkey is the private key
        generated by keygen. pubkeys is an array of the public keys in
        the ring, including the pubkeys corresponding to privkey. The
        message is an array of bytes.
        """
        k = int(sha256(message).hexdigest(), 16)
        v = randrange(1, p)
        messages = []
        n = len(pubkeys)
        indices = [i for i in range(n) if i != s] # s = index of signer
        for i in indices:
            e_i = pubkeys[i]
            a_i = randrange(1,p-1)
            while 1:
                b_i = randrange(1, p-1)
                if gcd(b_i, p-1) == 1:
                    break
            alpha_i = pow(g, a_i, p)*pow(e_i, b_i, p) % p
            beta_i = - alpha_i * invert(b_i, p-1) % (p-1)
            m_i = a_i * beta_i % (p-1)
            messages.append(m_i)

        raise NotImplementedError

    @staticmethod
    def verify(pubkeys, message, signature):
        """returns True iff the signature is correct."""
        raise NotImplementedError


class ElGamal:
    @staticmethod
    def keygen(size=1024):
        """returns a (public, private, generator, prime)-keypair."""
        p = gen_prime(size, extra_check=is_safe_prime)
        q = p//2
        while 1:
            g = randrange(3, p)
            if pow(g, 2, p) == 1:
                continue
            if pow(g, q, p) == 1:
                continue
            if divmod(p-1, g)[1] == 0:
                continue
            if divmod(p - 1, invert(g, p))[1] == 0:
                continue
            break
        d = randrange(2, p - 1)
        e = pow(g, d, p)
        return {'e': e, 'd': d, 'g': g, 'p': p}

    @staticmethod
    def sign(d, message, g, p):
        """returns a signature. The privkey is the private key
        generated by keygen. The message is an array of bytes.
        """
        m = int(sha256(message).hexdigest(), 16)
        l = randrange(2, p - 1)
        while gcd(l, p - 1) != 1:
            l = randrange(2, p - 1)
        alpha = pow(g, l, p)
        beta = (m - d*alpha)*invert(l, p - 1) % (p - 1)
        return alpha, beta

    @staticmethod
    def verify(e, message, signature, g, p):
        """returns True iff the signature is correct."""
        alpha, beta = signature
        if alpha < 1 or alpha >= p:
            return False
        m = int(sha256(message).hexdigest(), 16)
        return pow(g, m) == pow(e, alpha, p)*pow(e, alpha, p) % p
